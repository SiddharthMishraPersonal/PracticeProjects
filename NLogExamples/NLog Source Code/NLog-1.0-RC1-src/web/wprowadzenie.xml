<?xml version="1.0" encoding="windows-1250" ?>
<?xml-stylesheet type="text/xsl" href="style.xsl" ?>
<content lang="en" id="documentation" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <h2>Wprowadzenie do œledzenia aplikacji przy pomocy bibliteki NLog</h2>
    <p>Autor: Jaros³aw Kowalski &lt;<a href="mailto:jaak@jkowalski.net">jaak@jkowalski.net</a>&gt;</p>
    <div style="margin-left: 1cm; margin-right: 1cm">
        <font color="#006400">
            <i>
                Dawno, dawno temu, kiedy na œwiecie nie by³o jeszcze debugerów, a aplikacje by³y w wiêkszoœci oparte o tekstow¹ konsolê, programiœci umieszczali w nich instrukcje <a href="http://www.cplusplus.com/ref/cstdio/printf.html">printf</a>() wypisuj¹ce komunikaty diagnostyczne na ekran. Kilka lat póŸniej œwiat poszed³ znacznie do przodu i instrukcje printf() zosta³y zast¹pione przez Console.WriteLine()...
            </i>
        </font>
    </div>
    <p>
        Zapewne ka¿dy z nas napisa³ kiedyœ kod podobny do poni¿szego:
    </p>
    <code lang="C#">
        <![CDATA[
        static void Main()
        {
            Console.WriteLine("Program SuperApp zosta³ uruchomiony...");
            DoSomething(0);
            Console.WriteLine("Program SuperApp koñczy dzia³anie");
        }]]>
    </code>

    <p>Instrukcje Console.WriteLine() pe³ni¹ tu rolê instrukcji œledz¹cych, które informuj¹ 
        o dzia³aniu programu. Na ich podstawie mo¿emy siê zorientowaæ, czy program
        dzia³a poprawnie lub te¿ czy siê nie zawiesi³. Zwykle po jako-takim przetestowaniu instrukcje Console.WriteLine() 
        s¹ wy³¹czane, aby nie spowalniaæ dzia³ania programu.
        Czêsto jednak, po pewnym czasie przychodzi potrzeba ponownego w³¹czenia œledzenia w aplikacji, 
        dlatego te¿ instrukcje œledz¹ce w kodzie zwykle zamieniamy na komentarze zamiast fizycznie je usuwaæ.
    </p>
    <p>
        Po kilku iteracjach dochodzimy zwykle do wniosku, ¿e obs³uga œledzenia naszej aplikacji, 
        by³aby du¿o bardziej u¿yteczna, gdyby mo¿liwe by³o:
    </p>
    <ul>
        <li>
            sterowanie poziomem szczegó³owoœci informacji diagnostycznych (np. wyœwietlanie wy³¹cznie b³êdów i ostrze¿eñ lub bardzo dok³adne informacje przydatne do debugowania)
        </li>
        <li>w³¹czanie i wy³¹czanie œledzenia dla poszczególnych klas i bibliotek w trakcie dzia³ania programu, bez jego zatrzymywania</li>
        <li>
            zapisywanie komunikatów do pliku, systemowego dziennika zdarzeñ, do³¹czonego debugera, itp.
        </li>
        <li>wysy³anie szczególnie wa¿nych komunikatów mailem lub zapisywanie ich w bazie danych</li>
        <li>i wiele innych</li>
    </ul>
    <p>
        Wydaje siê, ¿e w dobie graficznych narzêdzi do debugowania u¿ytecznoœæ rozwi¹zañ opartych 
        na œledzeniu jest ma³a. Czêsto jednak s¹ to jedyne dostêpne narzêdzia, które musz¹ nam 
        wystarczyæ np. do zlokalizowania przyczyny b³êdu w krytycznym systemie dzia³aj¹cym na 
        serwerze, którego nie mo¿na wy³¹czyæ nawet na chwilê.
    </p>

    <h2>Czym jest NLog?</h2>
    <p>
        NLog <a href="http://www.nlog-project.org/">(http://www.nlog-project.org)</a> jest
        bibliotek¹ na platformie .NET, która umo¿liwia ³atwe wzbogacenie naszej
        aplikacji o obs³ugê œledzenia, realizuj¹c¹ wymagania opisane powy¿ej,
        a tak¿e du¿o wiêcej.
    </p>
    <p>
        Najproœciej rzecz ujmuj¹c NLog umo¿liwia tworzenie <b>regu³ </b>steruj¹cych przep³ywem
        komunikatów diagnostycznych od <b>Ÿród³a</b> do <b>celu</b>, którym mo¿e byæ:
    </p>
    <ul>
        <li>plik</li>
        <li>konsola tekstowa</li>
        <li>wiadomoœæ email</li>
        <li>baza danych</li>
        <li>inny komputer w sieci (protokó³ TCP/UDP)</li>
        <li>kolejka komunikatów MSMQ</li>
        <li>systemowy dziennik zdarzeñ (Event Log)</li>
        <li>
            i inne opisane na stronie <a href="http://www.nlog-project.org/targets.html">http://www.nlog-project.org/targets.html</a>
        </li>
    </ul>
    <p>
        Dodatkowo, ka¿dy komunikat diagnostyczny mo¿e byæ wzbogacony o <b>informacje kontekstowe</b>,
        które razem z nim zostan¹ przes³ane do celu. Mog¹ to byæ:
    </p>
    <ul>
        <li>bie¿¹ca data i godzina (w ró¿nych formatach)</li>
        <li>poziom wa¿noœci</li>
        <li>nazwa Ÿród³a</li>
        <li>informacje o metodzie, która wyemitowa³a komunikat diagnostyczny</li>
        <li>zawartoœci zmiennych œrodowiskowych</li>
        <li>informacje o wyj¹tku</li>
        <li>nazwa maszyny, procesu i w¹tku, który emituje komunikat</li>
        <li>
            i wiele innych opisanych na stronie <a href="http://www.nlog-project.org/layoutrenderers.html">http://www.nlog-project.org/layoutrenderers.html</a>
        </li>
    </ul>
    <p>
        Ka¿dy komunikat diagnostyczny ma swój poziom (log level). Wspierane s¹ nastêpuj¹ce poziomy
    </p>
    <ul>
        <li>
            <b>Trace </b>- Szczegó³owe komunikaty diagnostyczne o potencjalnie du¿ej czêstotliwoœci i objêtoœci
        </li>
        <li>
            <b>Debug </b>-Komunikaty diagnostyczne o niewielkiej czêstotliwoœci i ma³ej objêtoœci
        </li>
        <li>
            <b>Info </b>- Komunikaty informacyjne, zwykle niezbyt czêste
        </li>
        <li>
            <b>Warn </b>- Ostrze¿enia nie powoduj¹ce b³êdnego dzia³ania programu
        </li>
        <li>
            <b>Error </b>- B³êdy, które objawiaj¹ siê widocznym dla u¿ytkownika komunikatem
        </li>
        <li>
            <b>Fatal </b>- B³êdy krytyczne, po których aplikacja zwykle koñczy swoje dzia³anie
        </li>
    </ul>
    <p>
        NLog jest rozwi¹zaniem open source dostêpnym za darmo na licencji BSD.
        Najnowsz¹ wersjê biblioteki mo¿na zawsze pobraæ pod adresem
        <a href="http://www.nlog-project.org/download.html">http://www.nlog-project.org/download.html</a>.
        Dostêpny jest graficzny instalator, dziêki któremu mo¿na szybko i ³atwo zainstalowaæ NLoga w wybranym 
        miejscu, jak równie¿ (w najnowszej wersji), integracja z Visual Studio 2005 udostêpniaj¹ca:
    </p>
    <ul>
        <li>wybór biblioteki NLog.dll z okna <code>Add Reference...</code></li>
        <li>wsparcie dla kontekstowego podpowiadania sk³adni - Intellisense podczas edycji plików konfiguracyjnych</li>
        <li>szablony plików konfiguracyjnych</li>
        <li>code snippet</li>
    </ul>

    <h2>Pierwsza aplikacja wykorzystuj¹ca NLoga</h2>
    <p>
        Na pocz¹tek przyjrzyjmy siê, jak wygl¹da tworzenie aplikacji wykorzystuj¹cej NLog
        przy u¿yciu Visual Studio 2005.
        Przeanalizujemy 2 przyk³ady - jeden najprostszy, drugi bardziej skomplikowany,
        które pokazuj¹ jak ³atwo jest sterowaæ konfiguracj¹ logowania.
    </p>
    <p>
        Zaczynamy od utworzenia projektu w Visual Studio i dodania w nim pliku konfiguracyjnego NLoga.
        Bêdziemy siê pos³ugiwaæ jêzykiem C#, ale NLog równie dobrze obs³uguje VB.NET i inne
        jêzyki na platformie .NET. Instalator NLoga dodaje do okna "Add New Item..." kilka nowych opcji 
        pozwalaj¹cych nam na "szybki start". Dodajmy wiêc do projektu pusty plik konfiguracyjny NLoga
        (Empty NLog Configuration File).
    </p>
    <img src="introduction_addnewitem.gif" />
    <p>
        Zauwa¿my, ¿e automatycznie zosta³a dodana referencja do biblioteki NLog i w projekcie pojawi³
        siê plik o nazwie NLog.config o poni¿szej treœci:
    </p>

    <code lang="XML">
        <![CDATA[<?xml version="1.0" encoding="utf-8" ?>
        <nlog xmlns="http://www.nlog-project.org/schemas/NLog.xsd"
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

            <targets>
            </targets>

            <rules>
            </rules>
        </nlog>
        ]]>
    </code>

    <p>W oknie w³aœciwoœci dla tego pliku nale¿y zaznaczyæ opcjê "Copy To Output Directory":</p>
    <img src="introduction_copytooutput.gif" />

    <p>
        W sekcji <x>
            <targets />
        </x> dodajmy nastêpuj¹cy wpis definiuj¹cy wyjœcie na konsolê i format tego wyjœcia:
    </p>
    <code lang="XML">
        <![CDATA[
        <targets>
            <target name="console" xsi:type="Console" layout="${longdate}|${level}|${message}" />
        </targets>
        ]]>
    </code>
    <p>
        Zauwa¿my, ¿e po Visual Studio podpowie nam dostêpne nazwy elementów i ich atrybutów, a po wpisaniu
        <b>xsi:</b> uzyskamy listê dostêpnych celów logowania.
    </p>
    <img src="introduction_target_intellisense.gif" />

    <p>
        W sekcji <x>
            <rules />
        </x> dodajmy regu³ê kieruj¹c¹ komunikaty na poziomie Debug lub wy¿szym na konsolê.
    </p>

    <code lang="XML" escaped="true">
        <rules>
            <logger name="*" minlevel="Debug" writeTo="console" />
        </rules>
    </code>

    <p>
        Aby wys³aæ komunikat diagnostyczny pos³ugujemy siê obiektem klasy Logger, który udostêpnia metody o nazwach
        odpowiadaj¹cych poziomom wa¿noœci komunikatu. Obiekty Logger tworzymy za poœrednictwem klasy LogManager,
        najwygodniej jest w tym celu wywo³aæ metodê LogManager.GetCurrentClassLogger(), która tworzy Ÿród³o o takiej samej
        nazwie jak bie¿¹ca klasa.
    </p>
    <p>
        Zmodyfikujmy wygenerowany plik C# dodaj¹c na pocz¹tku polecenie using NLog, a w treœci klasy instrukcjê tworzenia
        obiektu Logger i wypisanie przyk³adowego komunikatu:
    </p>

    <code lang="C#">
        <![CDATA[
        using System;
        using System.Collections.Generic;
        using System.Text;
        using NLog;
        
        namespace NLogExample
        {
            class Program
            {
                private static Logger logger = LogManager.GetCurrentClassLogger();
                
                static void Main(string[] args)
                {
                    logger.Debug("Hello World!");
                }
            }
        }
        ]]>
    </code>
    <p>
        Wynikiem dzia³ania programu jest wypisana na konsoli tekstowej bie¿¹ca data, poziom logowania
        (<font face="Courier New">Debug</font>) i komunikat <font face="Courier New">Hello World</font>.
    </p>

    <p>
        Spróbujmy przeœledziæ teraz poszczególne etapy przetwarzania powy¿szego komunikatu diagnostycznego:
    </p>
    <ol>
        <li>
            Metoda <a href="http://www.nlog-project.org/help/NLog.LogManager.GetCurrentClassLogger.html">LogManager.GetCurrentClassLogger();</a>
            tworzy obiekt klasy <a href="http://www.nlog-project.org/help/NLog.Logger.html">Logger</a> reprezentuj¹cy <b>Ÿród³o</b>
            logowania powi¹zane z bie¿¹c¹ klas¹.
        </li>
        <li>
            Wywo³anie metody Debug() na tym obiekcie powoduje wys³anie zadanego komunikatu za
            poœrednictwem wskazanego Ÿród³a z poziomem logowania Debug
        </li>
        <li>
            Poniewa¿ poziom logowania i Ÿród³o odpowiadaj¹ zdefiniowanej regule,
            komunikat jest formatowany zgodnie z wartoœci¹ parametru layout elementu
            <x>
                <target />
            </x> i wysy³any na konsolê.
        </li>
    </ol>
    <h4>
        Bardziej skomplikowana konfiguracja logowania
    </h4>
    <p>
        Za³ó¿my, ¿e oprócz wypisywania na konsolê, chcemy jednoczeœnie zapisywaæ nasze komunikaty do pliku testowego i
        rejestrowaæ informacje o bie¿¹cym stosie wywo³añ, czyli nazwy metod. Zdefiniujmy drugi cel logowania typu plikowego i skierujmy wszystkie komunikaty do niego. W³¹czmy te¿ poziom Trace.
        Wymaga to jedynie dodania nowego elementu <x>
            <target />
        </x> typu File, modyfikacji regu³y <x>
            <logger />
        </x>
        a tak¿e zmodyfikowania parametru layout.
    </p>
    <code lang="XML">
        <![CDATA[<?xml version="1.0" encoding="utf-8" ?>
<nlog xmlns="http://www.nlog-project.org/schemas/NLog.xsd"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

    <targets>
        <target name="console" xsi:type="ColoredConsole" layout="${date:format=HH\:mm\:ss}|${level}|${stacktrace}|${message}" />
        <target name="file" xsi:type="File" fileName="${basedir}/file.txt" layout="${stacktrace} ${message}" />
    </targets>

    <rules>
        <logger name="*" minlevel="Trace" writeTo="console,file" />
    </rules>
</nlog>
        ]]>
    </code>


    <p>
        Wypiszmy tak¿e nieco wiêcej komunikatów na ró¿nych poziomach logowania. WprowadŸmy te¿ 
        kilka dodatkowych metod, tak aby zaobserwowaæ œlad stosu:
    </p>
    <code lang="C#">
        <![CDATA[
        static void C()
        {
            logger.Info("Info CCC");
        }
        static void B()
        {
            logger.Trace("Trace BBB");
            logger.Debug("Debug BBB");
            logger.Info("Info BBB");
            C();
            logger.Warn("Warn BBB");
            logger.Error("Error BBB");
            logger.Fatal("Fatal BBB");
        }
        static void A()
        {
            logger.Trace("Trace AAA");
            logger.Debug("Debug AAA");
            logger.Info("Info AAA");
            B();
            logger.Warn("Warn AAA");
            logger.Error("Error AAA");
            logger.Fatal("Fatal AAA");
        }
        static void Main(string[] args)
        {
            logger.Trace("Komunikat techniczny na poziomie Trace");
            logger.Debug("Komunikat techniczny na poziomie Debug");
            logger.Info("Komunikat informacyjny na poziomie Info");
            A();
            logger.Warn("Komunikat-ostrze¿enie na poziomie Warn");
            logger.Error("Komunikat o b³êdzie na poziomie Error");
            logger.Fatal("Komunikat o b³êdzie krytycznym na poziomie Fatal");
        }
    ]]>
    </code>
    <p>
        Uruchomienie programu spowoduje wypisanie na do pliku file.txt nastêpuj¹cych informacji:
    </p>
    <code lang="C#">
        <![CDATA[
Program.Main Komunikat techniczny na poziomie Trace
Program.Main Komunikat techniczny na poziomie Debug
Program.Main Komunikat informacyjny na poziomie Info
Program.Main => Program.A Trace AAA
Program.Main => Program.A Debug AAA
Program.Main => Program.A Info AAA
Program.Main => Program.A => Program.B Trace BBB
Program.Main => Program.A => Program.B Debug BBB
Program.Main => Program.A => Program.B Info BBB
Program.A => Program.B => Program.C Info CCC
Program.Main => Program.A => Program.B Warn BBB
Program.Main => Program.A => Program.B Error BBB
Program.Main => Program.A => Program.B Fatal BBB
Program.Main => Program.A Warn AAA
Program.Main => Program.A Error AAA
Program.Main => Program.A Fatal AAA
Program.Main Komunikat-ostrze¿enie na poziomie Warn
Program.Main Komunikat o b³êdzie na poziomie Error
Program.Main Komunikat o b³êdzie krytycznym na poziomie Fatal
]]>
    </code>
    <p>W tym samym czasie konsolê wypisana zostanie wiadomoœæ w innym formacie:</p>
    <img src="introduction_coloredconsole.gif" />
    <p>
        Za³ó¿my, ¿e chcemy do pliku zapisywaæ wszystkie informacje, a na konsolê jedynie te najistotniejsze
        (na poziomie <b>Info</b> lub wy¿szym). Nic prostszego, wystarczy jedynie zmieniæ sekcjê regu³:
    </p>
    <code lang="XML">
        <![CDATA[
            <rules>
                <logger name="*" minlevel="Info" writeTo="console" />
                <logger name="*" minlevel="Trace" writeTo="file" />
            </rules>
        ]]>
    </code>
    <p>
        Po uruchomieniu programu oka¿e siê, ¿e komunikaty na poziomie Trace i Debug s¹ zawarte wy³¹cznie w pliku,
        podczas gdy nie widzimy ich na konsoli.
    </p>
    <h2>Konfiguracja logowania</h2>
    <p>
        Czas teraz, aby odpowiedzieæ na pytanie: jak to siê sta³o, ¿e NLog automatycznie odczyta³ poprawn¹ konfiguracjê?
        Otó¿, w odró¿nieniu od innych narzêdzi tego typu, NLog stara siê maksymalnie u³atwiæ konfiguracjê, stosuj¹c rozmaite
        zachowania domyœlne. NLog szuka pliku konfiguracyjnego w nastêpuj¹cych standardowych lokalizacjach:
    </p>
    <ul>
        <li>
            standardowy plik konfiguracyjny programu (zwykle <font face="Courier New">aplikacja.exe.config)</font>
        </li>
        <li>
            plik <font face="Courier New">aplikacja.exe.nlog</font> w katalogu aplikacji
        </li>
        <li>
            plik <font face="Courier New">NLog.config</font> w katalogu aplikacji
        </li>
        <li>
            plik <font face="Courier New">NLog.dll.nlog</font> w katalogu, w którym znajduje siê plik <font face="Courier New">NLog.dll</font>
        </li>
        <li>
            jeœli istnieje zmienna œrodowiskowa <font face="Courier New">NLOG_GLOBAL_CONFIG_FILE</font>, sprawdzane jest miejsce wskazywane przez tê zmienn¹<font face="Courier New"></font>
        </li>
    </ul>
    <p>
        W przypadku aplikacji ASP.NET przeszukiwane s¹:
    </p>
    <ul>
        <li>
            standardowy plik konfiguracyjny <font face="Courier New">web.config</font>
        </li>
        <li>
            plik <font face="Courier New">web.nlog</font> w katalogu aplikacji (obok <font face="Courier New">web.config</font>)
        </li>
        <li>
            plik <font face="Courier New">NLog.config</font> w katalogu aplikacji
        </li>
        <li>
            plik <font face="Courier New">NLog.dll.nlog</font> w katalogu, w którym znajduje siê plik <font face="Courier New">NLog.dll </font>(zwykle "bin")
        </li>
        <li>
            jeœli istnieje zmienna œrodowiskowa <font face="Courier New">NLOG_GLOBAL_CONFIG_FILE</font>, sprawdzane jest miejsce wskazywane przez tê zmienn¹
        </li>
    </ul>
    <p>
        W œrodowisku .NET Compact Framework nie wystêpuje pojêcie pliku konfiguracyjnego aplikacji (*.exe.config) ani zmienne œrodowiskowe, dlatego sprawdzane s¹ tylko trzy lokalizacje:
    </p>
    <ul>
        <li>
            plik <font face="Courier New">aplikacja.exe.nlog</font> w katalogu aplikacji
        </li>
        <li>
            plik <font face="Courier New">NLog.config</font> w katalogu aplikacji
        </li>
        <li>
            plik <font face="Courier New">NLog.dll.nlog</font> w katalogu, w którym znajduje siê plik <font face="Courier New">NLog.dll</font>
        </li>
    </ul>
    <p>
        Przeszukiwany zestaw plików zosta³ tak dobrany, aby umo¿liwiæ automatyczn¹ konfiguracjê we wszystkich typowych trybach
        dzia³ania aplikacji bez koniecznoœci wykonywania ¿adnych dodatkowych czynnoœci.
    </p>
    <h4>Format pliku konfiguracyjnego</h4>
    <p>
        Dostêpne s¹ 2 formaty konfiguracji NLoga:
    </p>
    <ul>
        <li>osadzona wewn¹trz pliku konfiguracyjnego aplikacji</li>
        <li>uproszczona</li>
    </ul>
    <p>
        W pierwszym przypadku pos³ugujemy siê standardowym mechanizmem sekcji konfiguracyjnych, dziêki którym nasz plik wygl¹da
        jak poni¿ej:
    </p>
    <code lang="XML">
        <![CDATA[<?xml version="1.0" encoding="utf-8" ?>
        <configuration>
          <configSections>
            <section name="nlog" type="NLog.Config.ConfigSectionHandler, NLog" />
          </configSections>
          <nlog>
          </nlog>
        </configuration>
        ]]>
    </code>
    <p>
        Format uproszczony wystêpuje w przypadku plików z rozszerzeniem *.nlog oraz NLog.config i
        sk³ada siê bezpoœrednio z pliku XML zawieraj¹cego element <x>
            <nlog />
        </x> jako korzeñ.
        U¿ycie przestrzeni nazw jest opcjonalne, ale umo¿liwia dzia³anie mechanizmu Intellisense w Visual Studio.
    </p>
    <code lang="XML">
        <![CDATA[<?xml version="1.0" encoding="utf-8" ?>
        <nlog xmlns="http://www.nlog-project.org/schemas/NLog.xsd"
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        </nlog>
        ]]>
    </code>
    <h4>Elementy konfiguracyjne</h4>
    <p>
        Wewn¹trz elementu <x>
            <nlog />
        </x> mo¿na u¿ywaæ nastêpuj¹cych elementów, z czego zwykle u¿ywane s¹ dwa pierwsze elementy z poni¿szej listy.
    </p>
    <ul>
        <li>
            <x><targets /></x> - definiuje cele logowania
        </li>
        <li>
            <x><rules /></x> - definiuje regu³y kierowania komunikatów diagnostycznych
        </li>
        <li>
            <x><extensions /></x> - ³aduje rozszerzenia NLoga z pliku *.dll
        </li>
        <li>
            <x><include /></x> - do³¹cza zewnêtrzny plik konfiguracyjny
        </li>
        <li>
            <x><variable /></x> - ustawia wartoœæ zmiennej konfiguracyjnej
        </li>
    </ul>
    <h4>Cele</h4>
    <p>
        Wewn¹trz sekcji <x>
            <targets />
        </x> definiujemy cele logowania,
        które s¹ reprezentowane przez elementy <x>
            <target />
        </x>
        Ka¿dy cel musi mieæ okreœlone 2 atrybuty:
    </p>
    <ul>
        <li>
            <font face="Courier New">name</font> - nazwa
        </li>
        <li>
            <font face="Courier New">type</font> - typ celu (w przypadku korzystania z przestrzeni nazw xsi:type)
        </li>
    </ul>
    <p>
        Dodatkowo cele zwykle akceptuj¹ inne parametry - wp³ywaj¹ce na sposób zapisywania informacji diagnostycznej.
        Dla ka¿dego celu zestaw parametrów jest inny - s¹ one szczegó³owo opisane na stronie projektu
        jak równie¿ dostêpne kontekstowo w trakcie edycji pliku konfiguracyjnego dziêki Intellisense.
    </p>
    <p>
        Przyk³adowo - cel typu "File" (plik) akceptuje parametr "fileName" definiuj¹cy nazwê pliku a cel typu "Console"
        akceptuje parametr "error" okreœlaj¹cy czy komunikaty diagnostyczne maj¹ byæ wypisywane na standardowe wyjœcie
        (stdout) czy na standardowe wyjœcie dla b³êdów (stderr).
    </p>
    <p>
        NLog udostêpnia wiele predefiniowanych celów. S¹ one opisane na stronie projektu. Bardzo ³atwo jest tak¿e utworzyæ
        swój w³asny cel - wymaga to zaledwie kilkunastu wierszy kodu i jest opisane
        w <a href="http://www.nlog-project.org/documentation.html">dokumentacji projektu</a>.
    </p>
    <h4>Regu³y</h4>
    <p>
        Regu³y sterowania logowaniem definiujemy w sekcji <x>
            <rules />
        </x>. Jest to prosta tabela routingu, gdzie w
        ka¿dej regule na podstawie nazwy Ÿród³a i poziomu logowania mo¿emy skierowaæ wynik do okreœlonego celu lub
        listy celów. Dodatkowo mo¿emy zdecydowaæ czy po zapisaniu maj¹ byæ uwzglêdniane dalsze regu³y czy te¿ zakoñczyæ
        ich przetwarzanie.
    </p>
    <p>
        Ka¿dy wpis w tabeli routingu ma formê elementu <x>
            <logger />
        </x>, który przyjmuje nastêpuj¹ce atrybuty:
    </p>
    <ul>
        <li>
            <font face="Courier New">name</font> - nazwa Ÿród³a (mo¿e zawieraæ symbole wieloznaczne * na pocz¹tku i/lub na koñcu)
        </li>
        <li>
            <font face="Courier New">minlevel</font> - minimalny poziom logowania wymagany do tego aby regu³a zadzia³a³a
        </li>
        <li>
            <font face="Courier New">maxlevel</font> - maksymalny poziom logowania wymagany do tego aby regu³a zadzia³a³a
        </li>
        <li>
            <font face="Courier New">level</font> - poziom logowania (pojedynczy) wymagany do tego aby regu³a zadzia³a³a
        </li>
        <li>
            <font face="Courier New">levels </font>- lista poziomów logowania, które aktywuj¹ regu³ê
        </li>
        <li>
            <font face="Courier New">writeTo</font> - lista nazw celów, do których zapisaæ komunikat
        </li>
        <li>
            <font face="Courier New">final</font> - czy regu³a jest koñcz¹ca. Jeœli tak, po jej zadzia³aniu nie s¹ przetwarzane ¿adne dalsze regu³y
        </li>
    </ul>
    <p>
        Poni¿ej kilka przyk³adów:
    </p>
    <ul>
        <li>
            <x>
                <logger name="Name.Space.Klasa1" minlevel="Debug" writeTo="f1" />
            </x> - komunikaty z klasy <font face="Courier New">Klasa1</font> w przestrzeni nazw <font face="Courier New">Name.Space</font> na poziomie <font face="Courier New">Debug</font> lub wy¿szym s¹ zapisywane do celu "<font face="Courier New">f</font>1"
        </li>
        <li>
            <x>
                <logger name="Name.Space.Klasa1" levels="Debug,Error" writeTo="f1" />
            </x> - komunikaty z klasy <font face="Courier New">Klasa1</font> w przestrzeni nazw <font face="Courier New">Name.Space</font> na poziomach <font face="Courier New">Debug</font> i Error zapisywane do celu "<font face="Courier New">f2</font>"
        </li>
        <li>
            <x>
                <logger
             name="Name.Space.*" writeTo="f3,f4" />
            </x>
            - komunikaty ze wszystkich klas w przestrzeni nazw <font face="Courier New">Name.Space</font> niezale¿nie od ich poziomu s¹ zapisywane do celów "<font face="Courier New">f3</font>" i "<font face="Courier New">f4</font>"
        </li>
        <li>
            <x>
                <logger
             name="Name.Space.*"  minlevel="Debug" maxlevel="Error" final="true" />
            </x>
            - komunikaty ze wszystkich klas w przestrzeni nazw <font face="Courier New">Name.Space</font> na poziomie wiêkszym ni¿ <font face="Courier New">Debug</font> i mniejszym ni¿ <font face="Courier New">Error</font> (czyli <font face="Courier New">Debug,Info,Warn,Error</font>) s¹ odrzucane (poniewa¿ nie podano klauzuli <font face="Courier New">writeTo</font>) i nie s¹ przetwarzane dla nich kolejne regu³y (ze wzglêdu na <font face="Courier New">final="true"</font>)
        </li>
    </ul>
    <p>
        W najprostszych aplikacjach konfiguracja logowania wygl¹da zwykle tak, ¿e mamy jeden cel i jedn¹ regu³ê kieruj¹c¹
        komunikaty do niego w zale¿noœci od poziomu. W miarê jak aplikacja roœnie,
        pojawia siê potrzeba dodawania kolejnych celów i regu³. W przypadku NLoga jest to wyj¹tkowo proste.
    </p>
    <h4>Informacje kontekstowe</h4>
    <p>
        Najwiêksz¹ si³¹ NLoga w porównaniu z innymi narzêdziami tego typu jest mechanizm formatów (ang. layouts).
        S¹ to ma³e fragmenty tekstu otoczone par¹ nawiasów "<b>${</b>" (dolar + lewy nawias klamrowy) oraz "<b>}</b>"
        (prawy nawias klamrowy), które potrafi¹ wstawiaæ do tekstu elementy <b>informacji kontekstowej.</b>
        Mo¿na ich u¿ywaæ w bardzo wielu miejscach, przyk³adowo do sterowania formatem informacji wyœwietlanych na ekran
        lub zapisywanych do pliku, ale tak¿e do sterowania nazwami plików!
    </p>
    <p>
        Po co? Zobaczmy to na przyk³adzie. Za³ó¿my, ¿e chcemy wypisywaæ na konsolê tekstow¹ nastêpuj¹ce informacje:
    </p>
    <ul>
        <li>bie¿¹ca data i godzina</li>
        <li>nazwa klasy i metody, która spowodowa³a wypisanie komunikatu diagnostycznego</li>
        <li>
            poziom komunikatu diagnostycznego
        </li>
        <li>tekst komunikatu diagnostycznego</li>
    </ul>
    <p>Jak to zrobiæ? Nic prostszego:</p>
    <code lang="XML">
        <![CDATA[
        <target name="c" xsi:type="Console" layout="${longdate} ${callsite} ${level} ${message}" />
        ]]>
    </code>
    <p>
        Za³ó¿my teraz, ¿e chcemy aby komunikaty z ka¿dego Ÿród³a trafia³y do osobnego pliku. To jest równie ³atwe:
    </p>
    <code lang="XML">
        <![CDATA[
        <target name="f" xsi:type="File" fileName="${logger}.txt" />
        ]]>
    </code>

    <p>
        Jak widzimy, format <font face="Courier New">${logger}</font> zosta³ tutaj u¿yty w atrybucie
        <font face="Courier New">fileName</font>, co sprawia, ¿e ka¿dy komunikat diagnostyczny trafia do pliku o
        nazwie takiej jak nazwa Ÿród³a. Powy¿szy przyk³ad utworzy nam pliki:
    </p>
    <ul>
        <li>Name.Space.Klasa1.txt</li>
        <li>Name.Space.Klasa2.txt</li>
        <li>Name.Space.Klasa3.txt</li>
        <li>Inny.Name.Space.Klasa1.txt</li>
        <li>Inny.Name.Space.Klasa2.txt</li>
        <li>Inny.Name.Space.Klasa3.txt</li>
        <li>...</li>
    </ul>>
    <p>Czêstym wymaganiem jest przechowywanie logów z ka¿dego dnia w osobnym pliku. To równie¿ jest trywialne:</p>
    <code lang="XML">
        <![CDATA[
        <target name="f" xsi:type="File" filename="${shortdate}.txt" />
        ]]>
    </code>
    <p>
        Gdybyœmy chcieli dla ka¿dego u¿ytkownika naszej aplikacji zrobiæ osobny plik, wystarczy poni¿szy fragment kodu:
    </p>
    <code lang="XML">
        <![CDATA[
        <target name="f" xsi:type="File" filename="${windows-identity:domain=false}.txt" />
        ]]>
    </code>
    <p>
        Dziêki tej prostej operacji NLog utworzy nam pliki o nazwach takich jak loginy naszych u¿ytkowników:
    </p>
    <ol>
        <li>Administrator.txt</li>
        <li>MaryManager.txt</li>
        <li>EdwardEmployee.txt</li>
        <li>...</li>
    </ol>
    <p>
        Oczywiœcie mo¿liwe s¹ te¿ bardziej z³o¿one przypadki. Np. dla ka¿dego u¿ytkownika i daty tworzymy osobny
        plik w katalogu takim jak data:
    </p>
    <code lang="XML">
        <![CDATA[
        <target name="f" xsi:type="File" filename="${shortdate}/${windows-identity:domain=false}.txt" />
        ]]>
    </code>
    <p>Powsta³e pliki to:</p>
    <ol>
        <li>2006-01-01/Administrator.txt</li>
        <li>2006-01-01/MaryManager.txt</li>
        <li>2006-01-01/EdwardEmployee.txt</li>
        <li>2006-01-02/Administrator.txt</li>
        <li>2006-01-02/MaryManager.txt</li>
        <li>2006-01-02/EdwardEmployee.txt</li>
        <li>...</li>
    </ol>

    <p>
        NLog udostêpnia bardzo wiele predefiniowanych formatów. S¹ one opisane pod adresem <a href="http://www.nlog-project.org/layoutrenderers.html">http://www.nlog-project.org/layoutrenderers.html</a>.
        Bardzo ³atwo jest tak¿e utworzyæ swój w³asny format - wymaga to zaledwie kilkunastu wierszy kodu i jest opisane w <a href="http://www.nlog-project.org/documentation.html">dokumentacji projektu</a>.
    </p>

    <h4>Pliki do³¹czane i zmienne</h4>
    <p>
        Czasami celowe mo¿e byæ rozbicie pliku konfiguracyjnego na kilka mniejszcych. 
        NLog udostêpnia w tym celu mechanizm plików do³¹czanych. Aby w³¹czyæ je do konfiguracji wystarczy u¿yæ
        <x><include file="nazwapliku" /></x>. Warto wspomnieæ ¿e nazwapliku mo¿e zawieraæ elementy
        informacji kontekstowej, wiêc mo¿liwe s¹ zaawansowane scenariusze takie jak do³¹czanie ró¿nych
        plików na ró¿nych maszynach, jak w poni¿szym przyk³adzie, gdzie wczytujemy plik o takiej nazwie
        jak nazwa bie¿¹cej maszyny:
    </p>
    <code lang="XML">
        <![CDATA[
        <nlog>
            ...
            <include file="${basedir}/${machinename}.config" />
            ...
        </nlog>
        ]]>
    </code>
    <p>
        Zmienne pozwalaj¹ nam w skrócony sposób zapisywaæ z³o¿one lub powtarzalne wyra¿enia, takie jak nazwy plików. 
        Aby zdefiniowaæ zmienn¹ pos³ugujemy siê sk³adni¹ <x><variable name="var" value="xxx" /></x>. Aby u¿yæ jej wartoœæ pos³ugujemy siê sk³adni¹
        identyczn¹ jak przy informacjach kontekstowych, to znaczy: "${var}".
    </p>
    <code lang="XML">
        <![CDATA[
        <nlog>
            <variable name="logDirectory" value="${basedir}/logs/${shortdate}" />

            <targets>
                <target name="file1" xsi:type="File" filename="${logDirectory}/file1.txt" />
                <target name="file2" xsi:type="File" filename="${logDirectory}/file2.txt" />
            </targets>
        </nlog>
        ]]>
    </code>

    <h4>Rekonfiguracja</h4>
    <p>
        Pliki konfiguracyjne s¹ standardowo wczytywane na pocz¹tku pracy programu. W przypadku d³ugo dzia³aj¹cych 
        procesów (np. us³ug systemowych) czêsto zachodzi potrzeba zwiêkszenia poziomu logowania w trakcie dzia³ania.
        Aby umo¿liwiæ tak¹ rekonfiguracjê, NLog potrafi monitorowaæ plik konfiguracyjny aplikacji 
        i wczytywaæ go ponownie po wykryciu jakiejkolwiej zmiany. Aby w³¹czyæ ten mechanizm, wystarczy dodaæ w
        pliku konfiguracyjnym atrybut <x><nlog autoReload="true" /></x>.
    </p>

    <h4>Rozwi¹zywanie problemów z logowaniem</h4>
    <p>
        Czasami zdarza siê tak, ¿e pomimo skonfigurowania, aplikacja nie zapisuje logów. Przyczyn mo¿e byæ wiele, 
        najczêstszym problemem s¹ uprawnienia, szczególnie w aplikacji webowej. Zwykle okazuje siê, ¿e serwer aplikacji
        WWW nie ma prawa zapisu do katalogu, gdzie chcielibyœmy gromadziæ logi. Poniewa¿ NLog "zjada" wyj¹tki wystêpuj¹ce 
        podczas logowania, aplikacja mo¿e siê o tym nie dowiedzieæ. Jest kilka sposobów, aby stwierdziæ wystêpowanie 
        tego typu problemów.
    </p>
    <ul>
        <li>
            <x>
                <nlog throwExceptions="true" />
            </x>- dodanie atrybutu throwExceptions w pliku konfiguracyjnym powoduje,
            ¿e NLog nie maskuje wyj¹tków i s¹ one przekazywane do aplikacji. Ten atrybut jest przydatny w
            fazie uruchamiania. Po zakoñczeniu konfiguracji dobrze jest w³¹czyæ maskowanie wyj¹tków, tak aby przypadkowe
            problemy z logowaniem nie spowodowa³y awarii naszej aplikacji.
        </li>
        <li>
            <x>
                <nlog internalLogFile="file.txt" />
            </x>- dodanie atrybutu internalLogFilew pliku konfiguracyjnym powoduje,
            ¿e NLog zapisze do wskazanego pliku wewnêtrzne informacje u³atwiaj¹ce debugowanie, w
            tym wszystkie wyj¹tki jakie zostan¹ zg³oszone podczas logowania.
        </li>
        <li>
            <x>
                <nlog internalLogLevel="Trace|Debug|Info|Warn|Error|Fatal" />
            </x> - steruj¹cy poziomem wewnêtrznego logowania
        </li>
        <li>
            <x>
                <nlog internalLogToConsole="false|true" />
            </x> - wysy³a zawartoœæ wewnêtrznego logu na konsolê.
        </li>
        <li>
            <x>
                <nlog internalLogToConsoleError="false|true" />
            </x> - wysy³a zawartoœæ wewnêtrznego logu na wyjœcie b³êdów konsoli.
        </li>
    </ul>

    <h4>Przetwarzanie asynchroniczne, cele opakowuj¹ce i z³o¿one</h4>
    <p>
        Oprócz standardowych, NLog udostêpnia tak¿e tzw. wrapper targets i compound targets, czyli cele opakowuj¹ce i z³o¿one,
        które modyfikuj¹ dzia³anie innych celów. Mog¹ dodawaæ tym samym takie funkcje jak:
    </p>
    <ul>
        <li>przetwarzanie asynchroniczne (logowanie odbywa siê w osobnym w¹tku)</li>
        <li>ponawianie próby w przypadku b³êdu</li>
        <li>równowa¿enie obci¹¿enia (load balancing)</li>
        <li>buforowanie</li>
        <li>filtrowanie</li>
        <li>cele zapasowe (w przypadku awarii jedego celu prze³¹czamy siê na kolejny)</li>
        <li>i inne opisane na stronie <a href="http://www.nlog-project.org/targets.html">http://www.nlog-project.org/targets.html</a></li>
    </ul>
    <p>
        Aby zdefiniowaæ cel z³o¿ony b¹dŸ opakowuj¹cy w pliku konfiguracjnym, zagnie¿d¿amy 
        cel opakowany wewn¹trz odpowiedniego celu opakowuj¹cego. Zagnie¿d¿anie mo¿e byæ wielopoziomowe,
        wiêc mo¿emy modyfikowaæ dzia³anie celu na wiêcej ni¿ jeden sposób.
        Przyk³adowo, asynchroniczne logowanie do pliku z ponawianiem próby zapisu w przypadku b³êdu
        definiujemy w nastêpuj¹cy sposób.:
    </p>
    <code lang="XML">
        <![CDATA[
        <targets>
            <target name="n" xsi:type="AsyncWrapper">
                <target xsi:type="RetryingWrapper">
                    <target xsi:type="File" fileName="${file}.txt" />
                </target>
            </target>
        </targets>
        ]]>
    </code>
    <p>
        Ze wzglêdu na to, ¿e przetwarzanie asynchroniczne jest doœæ czêsto stosowane,
        NLog udostêpnia skrócon¹ sk³adniê pozwalaj¹c¹ w³¹czyæ to zachowanie dla wszystkich celów. Wystarczy w elemencie
        <x><targets /></x> dodaæ atrybut async="true".
    </p>

    <h2>Konfiguracja programowa</h2>
    <p>
        Zamiast pliku konfiguracyjnego NLog mo¿e byæ konfigurowany przy pomocy API.
        Pe³ny opis tej funkcji wykracza poza zakres artyku³u. W skrócie mo¿na powiedzieæ, ¿e polega 
        to na:
    </p>
    <ol>
        <li>utworzeniu obiektu klasy LoggingConfiguration</li>
        <li>utworzeniu jednego lub wiêcej celów (obiektów dziedzicz¹cych z klasy Target)</li>
        <li>ustawienie w³aœciwoœci celów</li>
        <li>zdefiniowanie regu³</li>
        <li>aktywowanie konfiguracji</li>
    </ol>
    <p>Poni¿ej krótki przyk³ad definiuj¹cy jeden cel typu "konsola tekstowa z kolorowaniem" i drugi plikowy oraz
    regu³ê kieruj¹c¹ do niego komunikaty na poziomie Debug lub wy¿szym:</p>
    <code lang="C#">
        <![CDATA[using NLog;
using NLog.Targets;
using NLog.Config;
using NLog.Win32.Targets;

class Example
{
    static void Main(string[] args)
    {
        // krok 1. tworzymy obiekt konfiguracji
        
        LoggingConfiguration config = new LoggingConfiguration();
        
        // krok 2. tworzymy cel(e) i dodajemy je do konfiguracji

        ColoredConsoleTarget consoleTarget = new ColoredConsoleTarget();
        config.AddTarget("console", consoleTarget);
        
        FileTarget fileTarget = new FileTarget();
        config.AddTarget("file", fileTarget);
        
        // krok 3 - ustawiamy w³aœciwoœci celów
        
        consoleTarget.Layout = "${date:format=HH\\:MM\\:ss} ${logger} ${message}";
        fileTarget.FileName = "${basedir}/file.txt";
        fileTarget.Layout = "${message}";
        
        // krok 4 - definiujemy regu³y
        
        LoggingRule rule1 = new LoggingRule("*", LogLevel.Debug, consoleTarget);
        config.LoggingRules.Add(rule1);

        LoggingRule rule2 = new LoggingRule("*", LogLevel.Debug, fileTarget);
        config.LoggingRules.Add(rule2);
        
        // krok 5. aktywowanie konfiguracji
        LogManager.Configuration = config;
        
        // przyk³ady u¿ycia

        Logger logger = LogManager.GetLogger("Example");
        logger.Trace("trace log message");
        logger.Debug("debug log message");
        logger.Info("info log message");
        logger.Warn("warn log message");
        logger.Error("error log message");
        logger.Fatal("fatal log message");
    }
}]]>
    </code>
    <p>
        Wynikiem dzia³ania powy¿szej aplikacji jest wypisany tekst na konsoli,
        gdzie ka¿dy wiersz jest oznaczony kolorem wynikaj¹cym z poziomu logowania
        i dodatkowo plik zawieraj¹cy te same informacje w nieco innym formacie.
    </p>
    <h2>Co jeszcze mo¿na zrobiæ w NLogu?</h2>
    <p>
        NLog udostêpnia jeszcze wiele funkcji, które ze wzglêdu na objêtoœæ nie mog³y
        zostaæ omówione w niniejszym artykule. Ka¿da z tych funkcji mog³aby byæ tematem na osobny artyku³.
    </p>
    <ul>
        <li>
            logowanie wyj¹tków - <a href="http://sourceforge.net/mailarchive/forum.php?thread_id=6766833&amp;forum_id=41984">http://sourceforge.net/mailarchive/forum.php?thread_id=6766833&amp;forum_id=41984</a>
        </li>
        <li>
            jêzyk warunków logicznych u¿ywanych przy filtrowaniu - <a href="http://www.nlog-project.org/filters.html">http://www.nlog-project.org/conditions.html</a>
        </li>
        <li>
            NLogViewer - aplikacja do podgl¹du logów w czasie rzeczywistym (wersja pre-alpha) -  <a href="http://viewer.nlog-project.org/">http://viewer.nlog-project.org/</a>
        </li>
    </ul>
</content>
